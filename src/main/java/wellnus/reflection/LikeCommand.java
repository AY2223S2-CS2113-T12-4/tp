package wellnus.reflection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import wellnus.command.Command;
import wellnus.exception.BadCommandException;

/**
 * Like command to add commands to favorite list.
 *
 * @@author wenxin-c
 */
public class LikeCommand extends Command {
    private static final String COMMAND_KEYWORD = "like";
    private static final String FEATURE_NAME = "reflect";
    private static final String INVALID_COMMAND_MSG = "Command is invalid.";
    private static final String INVALID_COMMAND_NOTES = "Please check the available commands "
            + "and the format of commands.";
    private static final String WRONG_INDEX_MSG = "Please input the correct index of the question you like!";
    private static final String COMMAND_KEYWORD_ASSERTION = "The key should be like.";
    private static final String MISSING_SET_QUESTIONS = "A set of questions has not been gotten";
    private static final String MISSING_SET_QUESTIONS_NOTES = "Please get a set of questions before adding to favorite "
            + "list!";
    private static final String ADD_FAV_SUCCESS_ONE = "You have added question: ";
    private static final String ADD_FAV_SUCCESS_TWO = " into favorite list!!";
    private static final String DUPLICATE_LIKE = " is already in the favorite list!";
    private static final int ARGUMENT_PAYLOAD_SIZE = 1;
    private static final int UPPER_BOUND = 5;
    private static final int LOWER_BOUND = 1;
    private static final int INDEX_ONE = 1;
    private static final int INDEX_ZERO = 0;
    private static final Logger LOGGER = Logger.getLogger("ReflectLikeCommandLogger");
    private static final ReflectUi UI = new ReflectUi();
    private ArrayList<HashSet<Integer>> dataIndex;
    private HashMap<String, String> argumentPayload;
    private Set<Integer> randomQuestionIndexes;
    private QuestionList questionList;

    /**
     * Set up the argument-payload pairs for this command.<br/>
     * Pass in a questionList object from ReflectionManager to access the indexes of the previous set of questions.
     *
     * @param arguments Argument-payload pairs from users
     * @param questionList Object that contains the data about questions
     * @throws BadCommandException If an invalid command is given
     */
    public LikeCommand(HashMap<String, String> arguments, QuestionList questionList) throws BadCommandException {
        super(arguments);
        this.argumentPayload = getArguments();
        this.questionList = questionList;
        this.randomQuestionIndexes = questionList.getRandomQuestionIndexes();
        this.dataIndex = questionList.getDataIndex();
    }

    /**
     * Get the command itself.
     *
     * @return Command: like
     */
    @Override
    protected String getCommandKeyword() {
        return COMMAND_KEYWORD;
    }

    /**
     * Get the name of the feature in which this get command is generated.
     *
     * @return Feature name: reflect
     */
    @Override
    protected String getFeatureKeyword() {
        return FEATURE_NAME;
    }

    /**
     * Validate the command.<br/>
     * <br/>
     * Conditions for command to be valid:<br/>
     * <li>Only one argument-payload pair
     * <li>The pair contains key: like
     * <li>Payload must be string which parse into integer ranges from 1 to 5
     * Whichever mismatch will cause the command to be invalid.
     *
     * @param commandMap Argument-Payload map generated by CommandParser
     * @throws BadCommandException If an invalid command is given
     */
    @Override
    public void validateCommand(HashMap<String, String> commandMap) throws BadCommandException, NumberFormatException {
        if (commandMap.size() != ARGUMENT_PAYLOAD_SIZE) {
            throw new BadCommandException(INVALID_COMMAND_MSG);
        } else if (!commandMap.containsKey(COMMAND_KEYWORD)) {
            throw new BadCommandException(INVALID_COMMAND_MSG);
        } else {
            int questionIndex = Integer.parseInt(commandMap.get(COMMAND_KEYWORD));
            if (questionIndex > UPPER_BOUND || questionIndex < LOWER_BOUND) {
                throw new BadCommandException(WRONG_INDEX_MSG);
            }
        }
    }

    /**
     * Entry point to this command.<br/>
     * Check the validity of commands and add into favorite list.<br/>
     */
    @Override
    public void execute() {
        try {
            validateCommand(this.argumentPayload);
        } catch (BadCommandException badCommandException) {
            LOGGER.log(Level.INFO, INVALID_COMMAND_MSG);
            UI.printErrorFor(badCommandException, INVALID_COMMAND_NOTES);
            return;
        } catch (NumberFormatException numberFormatException) {
            LOGGER.log(Level.INFO, WRONG_INDEX_MSG);
            UI.printErrorFor(numberFormatException, WRONG_INDEX_MSG);
            return;
        }
        assert argumentPayload.containsKey(COMMAND_KEYWORD) : COMMAND_KEYWORD_ASSERTION;
        try {
            addFavQuestion(this.argumentPayload.get(COMMAND_KEYWORD));
        } catch (BadCommandException badCommandException) {
            LOGGER.log(Level.INFO, MISSING_SET_QUESTIONS);
            UI.printErrorFor(badCommandException, MISSING_SET_QUESTIONS_NOTES);
        }
    }

    /**
     * User input index ranges from 1 to 5.
     * Since the questions have a unique and fixed index, this function maps the user input index to the real index
     * of the question in the questions list.
     *
     * @return IndexQuestionMap
     */
    HashMap<Integer, Integer> mapInputToQuestion() {
        HashMap<Integer, Integer> indexQuestionMap = new HashMap<>();
        int targetedIndex = INDEX_ONE;
        for (int index : this.randomQuestionIndexes) {
            indexQuestionMap.put(targetedIndex, index);
            targetedIndex += INDEX_ONE;
        }
        return indexQuestionMap;
    }

    /**
     * Add this index to favorite list and print the question to be added.<br/>
     * <br/>
     * A valid index will only be added(i.e. passed validateCommand()):
     * <li> There is a set of questions gotten previously
     * <li> The question is not yet in the favorite list
     *
     * @param questionIndex User input of the index of question to be added to favorite list.
     * @throws BadCommandException If there is not a set of question generated yet.
     */
    public void addFavQuestion(String questionIndex) throws BadCommandException {
        int questionIndexInt = Integer.parseInt(questionIndex);
        if (this.randomQuestionIndexes.isEmpty()) {
            throw new BadCommandException(MISSING_SET_QUESTIONS);
        }
        HashMap<Integer, Integer> indexQuestionMap = mapInputToQuestion();
        int indexToAdd = indexQuestionMap.get(questionIndexInt);
        ArrayList<ReflectionQuestion> questions = this.questionList.getAllQuestions();
        if (this.dataIndex.get(INDEX_ZERO).contains(indexToAdd)) {
            UI.printOutputMessage(questions.get(indexToAdd).toString() + DUPLICATE_LIKE);
            return;
        }
        this.dataIndex.get(INDEX_ZERO).add(indexToAdd);
        questionList.setDataIndex(this.dataIndex);
        UI.printOutputMessage(ADD_FAV_SUCCESS_ONE + questions.get(indexToAdd).toString() + ADD_FAV_SUCCESS_TWO);
    }
}

